<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on M. Rincón</title><link>https://mrincon.net/tags/linux/</link><description>Recent content in Linux on M. Rincón</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>M. Rincón</copyright><lastBuildDate>Fri, 28 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://mrincon.net/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Working with biggish data files</title><link>https://mrincon.net/posts/csv/</link><pubDate>Fri, 28 Jul 2023 00:00:00 +0000</pubDate><guid>https://mrincon.net/posts/csv/</guid><description>&lt;p>
Last week I worked with over 10,000 files of tabular data, each with about 50,000 rows and
10 columns separated by a &amp;#39;|&amp;#39;. This is the kind of problem that falls in the uncanny
valley between small and biggish data. My goal was to make some quick checks and, if
possible, concatenate the files into a single &lt;code>csv&lt;/code> file I could load into Python.&lt;/p>
&lt;p>
The first step was to make sure that the number and order of the columns was the same
for all files:&lt;/p>
&lt;div class="src src-sh">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">head -q -n &lt;span class="m">1&lt;/span> *.dat &lt;span class="p">|&lt;/span> sort &lt;span class="p">|&lt;/span> uniq&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
While the revealed that not all headers were the same, the differences were insignificant.
For example, some files used &amp;#34;NET_CHANGE&amp;#34; while other used &amp;#34;NET CHANGE&amp;#34;. One file seemed
to quote the first line. Other files were terminated with carriage return and new line
pairs. But worryingly, some files seemed to start with an empty line. I didn&amp;#39;t know if
these files were empty, or if they have a different format. I made a list of the files,
and opened a sample:&lt;/p>
&lt;div class="src src-sh">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">head -n &lt;span class="m">1&lt;/span> -v *.dat &lt;span class="p">|&lt;/span> grep -B1 -E &lt;span class="s1">$&amp;#39;^\r$&amp;#39;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
It turned out that these files had an extra empty line terminated by a carriage return on
the first line. Lucky. I removed the carriage returns and the empty lines and all the files:&lt;/p>
&lt;div class="src src-sh">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">sed -i &lt;span class="s1">$&amp;#39;s/\r//&amp;#39;&lt;/span> *.dat &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sed -i &lt;span class="s1">&amp;#39;/^[[:blank:]]*$/ d&amp;#39;&lt;/span> *.dat&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
Now all the headers appeared to be about the same, and I shouldn&amp;#39;t have any empty lines.
Still, I took a second look:&lt;/p>
&lt;div class="src src-sh">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">grep -E &lt;span class="s1">$&amp;#39;^$&amp;#39;&lt;/span> *.dat&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
At this point I noticed that some file sizes were only big enough to hold a header line.
Looking at their tails proved my suspicion correct. I deleted them using vim:&lt;/p>
&lt;div class="src src-sh">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">:r !du -ckhs * &lt;span class="p">|&lt;/span> grep &lt;span class="s2">&amp;#34;^4\.0K&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:%s/^4.*&lt;span class="se">\t&lt;/span>/rm
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">:w !sh&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
At this point I went ahead and concatenated the files. Since I only wanted to preserve
one header, I used &lt;code>awk&lt;/code>.&lt;/p>
&lt;div class="src src-sh">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">head -n1 2023_04_27.dat &amp;gt; all.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">awk FNR!&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span> *.dat &amp;gt;&amp;gt; all.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">du -h all.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">wc -l all.txt&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
The result was one file with a little under six hundred million lines. Because I wanted a
&lt;code>csv&lt;/code> file, I removed any existing commas, and changed the separator from &amp;#39;|&amp;#39; to &amp;#39;,&amp;#39;:&lt;/p>
&lt;div class="src src-sh">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">sed -i &lt;span class="s1">&amp;#39;s/,//g&amp;#39;&lt;/span> all.txt &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> sed -i &lt;span class="s1">&amp;#39;s/|/,/g&amp;#39;&lt;/span> all.txt&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
I also checked that the resulting file wasn&amp;#39;t jagged, and it wasn&amp;#39;t:&lt;/p>
&lt;div class="src src-sh">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">cat input.csv &lt;span class="p">|&lt;/span> grep -v &lt;span class="s2">&amp;#34;^#&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> awk &lt;span class="s2">&amp;#34;{print NF}&amp;#34;&lt;/span> &lt;span class="nv">FS&lt;/span>&lt;span class="o">=&lt;/span>, &lt;span class="p">|&lt;/span> uniq&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
At this point I could have fired &lt;code>Dask&lt;/code>, but I thought I could do better and reduce the file
to something &lt;code>Polars&lt;/code> could handle. After taking a look at the original files, I suspected
some redundancy. For example, one column showed the three character product code, another
had the numerical code, and another a product description. This suggested I could use one
of the codes as a key I could use to map to a second file with the numerical code and
description. Using &lt;code>shuf&lt;/code> I made a sample, split it, and recovered the original file using
&lt;code>join&lt;/code> and &lt;code>diff&lt;/code>. Nice. The file could be divided, and doing that reduced the size of the
data be over 60% without loosing any information.&lt;/p>
&lt;div class="src src-sh">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">cut -d&lt;span class="s1">&amp;#39;,&amp;#39;&lt;/span> -f1,4-7,8 all.txt &amp;gt; px.csv
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cut -d&lt;span class="s1">&amp;#39;,&amp;#39;&lt;/span> -f2-3,5-6,11 all.txt &lt;span class="p">|&lt;/span> sort &lt;span class="p">|&lt;/span> uniq &amp;gt; description.csv&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
Now the final file was small enough for me to inspect locally with &lt;code>polars&lt;/code>.&lt;/p></description></item><item><title>Making ProtonVPN Usable on Linux</title><link>https://mrincon.net/posts/pvpn/</link><pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate><guid>https://mrincon.net/posts/pvpn/</guid><description>&lt;p>
ProtonVPN provides a GUI and a console application for Linux, but on 2023, it is nearly
unusable. It consumes up to 2 GB of memory idled, drops connections, and fails to
reconnect unless the kill switch is deleted using &lt;code>nmcli&lt;/code>. The command line application has
a &lt;a href="https://github.com/ProtonVPN/linux-cli/issues/62">bizarre dependency&lt;/a> on &lt;code>nm-applet&lt;/code>, which of course means it cannot be used on a headless
machine. It &lt;a href="https://github.com/ProtonVPN/linux-app/issues/49">appears&lt;/a> that &lt;code>ProtonVPN&lt;/code> is not going to fix this. The solution is to use
&lt;code>ProtonVPN&lt;/code> with &lt;code>Wireguard&lt;/code>.&lt;/p>
&lt;p>
First, install &lt;code>Wireguard&lt;/code> and &lt;code>ufw&lt;/code>. Then, log into &lt;code>ProtonVPN&lt;/code>, and in the download section,
get a few &lt;code>Wireguard&lt;/code> configuration files. Add them to the &lt;code>NetworkManager&lt;/code>. By default, all
new &lt;code>wireguard&lt;/code> connections will auto connect on start up. Since I only want one default
connection, I modified all but one. In addition, I disabled &lt;code>IPv6&lt;/code> on all the connection.&lt;/p>
&lt;div class="src src-sh">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">nmcli con import &lt;span class="nb">type&lt;/span> wireguard file &amp;lt;connection.conf&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nmcli con modify &amp;lt;connection&amp;gt; ipv6.method &lt;span class="s2">&amp;#34;ignore&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># if not the default connection:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nmcli con mod &amp;lt;connection&amp;gt; connection.autoconnect no
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nmcli con down &amp;lt;connection&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nmcli -f name,autoconnect connection&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
I also wanted a &lt;code>killswitch&lt;/code>, so I used &lt;code>ufw&lt;/code> to configure one (Fedora comes with &lt;code>FirewallD&lt;/code>,
but I&amp;#39;m familiar with &lt;code>ufw&lt;/code>). First I disabled connections outside my &lt;code>LAN&lt;/code>. Because I want to
be able to reconnect without turning off the firewall, I made exceptions for the &lt;code>VPN&lt;/code>
connections by allowing paths to the end points in the configuration files.&lt;/p>
&lt;div class="src src-sh">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># ignore the 127.0.0.1/8 range, that&amp;#39;s the loop back&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ip address &lt;span class="p">|&lt;/span> grep inet
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ufw reset
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ufw default deny outgoing
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ufw default deny incoming
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># whitelist the range found with ip address&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ufw allow in to &amp;lt;range start/end&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ufw allow out to&amp;lt;range start/end&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ufw allow out to &amp;lt;ip&amp;gt; port &amp;lt;port number&amp;gt; proto udp
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ufw allow out on &amp;lt;connection&amp;gt; from any to any
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ufw enable&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
At this point there shouldn&amp;#39;t be any connection outside the &lt;code>LAN&lt;/code> unless I have a &lt;code>VPN&lt;/code>
connections.&lt;/p>
&lt;div class="src src-sh">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># ping google should fail&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ping 8.8.8.8
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># but work after vpn is activate&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nmcli --ask con up &amp;lt;vpn name&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ping google
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># we can also check for leaks&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">curl https://ipleak.net/json/ &lt;span class="p">|&lt;/span> jq
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># and in the DNS&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">session&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>&lt;span class="nb">echo&lt;/span> mrfox &lt;span class="p">|&lt;/span> sha1sum&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> i in &lt;span class="k">$(&lt;/span>seq &lt;span class="m">5000&lt;/span> 5003&lt;span class="k">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">do&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> curl &lt;span class="s2">&amp;#34;https://&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">session&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">0&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nv">40&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">-&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">.ipleak.net/dnsdetection/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> sleep &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">done&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>
If all works as expected, &lt;code>ufw&lt;/code> can be set as a service.&lt;/p>
&lt;div class="src src-sh">
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sh" data-lang="sh">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># If active, disable firewalld&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">systemctl disable --now firewalld.service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">systemctl &lt;span class="nb">enable&lt;/span> --now ufw.service
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ufw status
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># To see what was blocked&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">journalctl -t kernel -fag &lt;span class="s2">&amp;#34;UFW BLOCK&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div></description></item></channel></rss>